\part{Overview}

\section{Team Members and Responsibilities}
\todo[inline]{Who worked on what specifically}

The members of the alpha team and their respective roles are:

Devin Schwab - Group Leader, Velocity Profiler

Mark Shultz - Steering

David Jannotta - Path Planning

Eddie Massey - Sensors

Each team member was given a specific node to work on.  This allows us
to work in parallel as the interfaces to our nodes are defined in the
software architecture. Along with the main tasks various other tasks
have been assigned.

For instance Eddie has been tasked with creating a ROS Launch file
(see Tools section) and Mark has been tasked with creating our package
structure (see Packaging and Stacks section).


\section{Project Goals}
\todo[inline]{What we would like our robot to do at the end of the
  semester.}
The main goal for the semester is to program a robot that is capable
of taking in sensory information from the environment and then use
that information to autonomously plan goals and execute them.  To
accomplish this overall goal multiple capabilities will need to be
added to the robot.  These capabilities include:

\begin{enumerate}
\item Take in goal destinations and calculate a path based on stored
  map information and current location
\item Autocorrect path when obstacles are detected
\item Correct trajectory using a steering algorithm
\item Detect objects using the Kinect camera and autonomously plan
  actions based on the data
\end{enumerate}

\todo[color=green,inline]{Fill out more information about each subtask}

\section{Schedule and Milestones}

\begin{longtable}{|l|l|}
  \hline {\bf Week} & {\bf Goal} \\ \hline
Weeks 1-3 & Familiarization with ROS \\ \hline
Week 4 & Dead Reckoning Demo \\ \hline
Week 5 & Velocity Profiling Demo \\ \hline
Week 6 & Estop Demo \\ \hline
Week 7 & Obstacle Detection Demo \\ \hline
Week 8 & Steering Demo \\ \hline
Week 9 & Spring Break - Code Refactoring \\ \hline
Week 10 & Obstacle Navigation \\ \hline
\end{longtable}

Over spring break we are planning on refactoring our code.  We will
also be investigating the use of python.

\section{Tools}
\todo[inline]{E.g. Git and roslaunch files}

\subsection{Git}

In order to keep track of the different versions of our source files
we are using git.  Our git repository can be found at
\url{https://github.com/rhololkeolke/EECS-376-Alpha}.  Using Git has
allowed us to work in parallel on the different files in our source
code and merge the various edits together.  It also has the added
benefit of keeping track of every version of our source code. There
have been many times that we have tried new changes, found they didn't
work and had to revert back to an earlier working version.

In order to keep everything organized each of us has a branch for
development.  We have also have a main branch called develop in which
we merge everyone's individual commits and do final tweaks. Every
demo is merged into master and tagged for future reference.

Below is a picture of the graph of our git repository.
\missingfigure{Add an image of the repository graph}

\subsection{ROS Launch}

\input{ros_launch}

\subsection{GTest}

GTest is Google's C++ Unit testing
framework.\cite{google_googletest} ROS recommends
its use for unit testing needs.  We are currently using it to test
helper classes, but would like to expand its use to other parts of our
code, including the main nodes.

The use of unit testing help solidify development by forcing us to
think about the interfaces of our classes before we start coding.
This in theory leads to cleaner, better designed code.  In addition
when adding new features or fixing bugs it is possible to break
previously implemented features.  Running the unit test suite after
each build will alert us of any regressions.

We would like to be able to write automated test suites for our code
that actually simulate the outcome in Stage. However, so far this is
just an idea.  If implemented it would allow us to systematically test
our code in the simulator and potentially automatically collect data.
For example when picking the steering constants had we had a way to
automate the simulator we could have written a short program to
autotune the robot.  Granted, it would still have to tweaked when it
ran on the real bot due to differences between simulation and the real world.