\part{Overview}

\section{Team Members and Responsibilities}
\todo[color=green,inline]{Update the group responsibilities}

The members of the alpha team and their respective roles are:

Devin Schwab - Group Leader, Velocity Profiler/Brushfire, A* Search

Mark Shultz - Steering, Kinect Sensor, Costmap, Brushfire

David Jannotta - Path Planning, Goal Planner

Eddie Massey III - Look Ahead, A* Search\\

In general each team member was given a specific node to work on. This allowed us to work in parallel as the interfaces to our nodes were defined prior to each node being created. However, there was some overlap between who worked on what node based on group member's expertise and availability.  For instance the Brushfire node was worked on by both Mark and Devin.

In addition to the actual coding work various other tasks were assigned. This included things like the creation of launch files, the collection of bag files and documentation.

\section{Project Goals}
The main goal for this semester was the final project. The final project involved navigating through an environment with unknown obstacles to a piece of metal, picking up the piece of metal and navigating back to the start. To accomplish this the robot needed the following capabilities:

\begin{enumerate}
     \item Take in goal destination and calculate a path to the location based on stored map information and current location
     \item Detect objects using sensors such as the Microsoft Kinect
     \item Update the overall plan as new obstacles are detected
     \item Calculate a trajectory along the desired path
\end{enumerate}

\todo[color=green,inline]{Fill out more information about each subtask}

\section{Schedule and Milestones}

\begin{longtable}{|l|l|}
  \hline {\bf Week} & {\bf Goal} \\ \hline
Weeks 1-3 & Familiarization with ROS \\ \hline
Week 4 & Dead Reckoning Demo \\ \hline
Week 5 & Velocity Profiling Demo \\ \hline
Week 6 & Estop Demo \\ \hline
Week 7 & Obstacle Detection Demo \\ \hline
Week 8 & Steering Demo \\ \hline
Week 9 & Spring Break - Code Refactoring \\ \hline
Week 10 & Obstacle Navigation \\ \hline
Week 11 & Kinect Implementation \\ \hline
Week 12 & Farmiliarization with OpenCV and Pointcloud Library \\ \hline
Week 13 & Strap Follower Demo \\ \hline
Week 14 & Costmap Integration \\ \hline
Week 15 & Path Planning Algorithims \\ \hline
Week 16 & Integration of New Nodes \\ \hline
\end{longtable}

After spring break we refactored our code in python and sought to farmiliarize ourselves with image processing libraries to be prepared for the final demo.

\section{Tools}

\subsection{Git}

In order to keep track of the different versions of our source files
we are using git.  Our git repository can be found at
\url{https://github.com/rhololkeolke/EECS-376-Alpha}.  Using Git has
allowed us to work in parallel on the different files in our source
code and merge the various edits together.  It also has the added
benefit of keeping track of every version of our source code. There
have been many times that we have tried new changes, found they didn't
work and had to revert back to an earlier working version.

In order to keep everything organized each of us has a branch for
development.  We have also have a main branch called develop in which
we merge everyone's individual commits and do final tweaks. Every
demo is merged into master and tagged for future reference.

\subsection{ROS Launch}

\input{ros_launch}

\todo[color=red,inline]{Replace with a section on Pytest and integration tests}
\subsection{GTest}

GTest is Google's C++ Unit testing
framework.\cite{google_googletest} ROS recommends
its use for unit testing needs.  We are currently using it to test
helper classes, but would like to expand its use to other parts of our
code, including the main nodes.

The use of unit testing help solidify development by forcing us to
think about the interfaces of our classes before we start coding.
This in theory leads to cleaner, better designed code.  In addition
when adding new features or fixing bugs it is possible to break
previously implemented features.  Running the unit test suite after
each build will alert us of any regressions.

We would like to be able to write automated test suites for our code
that actually simulate the outcome in Stage. However, so far this is
just an idea.  If implemented it would allow us to systematically test
our code in the simulator and potentially automatically collect data.
For example when picking the steering constants had we had a way to
automate the simulator we could have written a short program to
autotune the robot.  Granted, it would still have to tweaked when it
ran on the real bot due to differences between simulation and the real world.
