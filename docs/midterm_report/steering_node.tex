\section{Steering Node}

The Steering node is responsible for taking the desired velocities from
the velocity planner, the desired path from the path planner, and the
current position to determine correction factors to the velocity command
such that the robot does not stray from its desired path.

\subsection{Theory of Operation}

The velocity profiler's job is to decide what velocity the robot
should be moving at for each point along the path.  The steering
node's job is to take the desired velocities and add correction
factors to them.

To do so steering subscribes to the des\_vel topic published by
Velocity Profiler.  In turn Velocity Profiler subscribes to the
velocity command actually sent to the robot. Velocity Profiler uses
this information to correct its internal state so that it is inline
with the robot's actual state.  The process runs continously forming a
cycle.

\subsubsection{Steering Algorithm}

We will use the linear steering algorithm. This algorithm takes a number
of inputs such as:

\begin{itemize}
\item
  The $x$ and $y$ coordinates of the destination.
\item
  The current $x$ and $y$ coordinates.
\item
  Tuning parameters $K_d$ and $K_\theta$
\end{itemize}
First we use the path segment coordinates to calculate the desired
heading with the following: $atan(yf-ys,xf-xs)$. Next we find a
$d_\theta$ by subtracting $heading_{dest}-heading_{curr}$. We can
prevent turning the long way by checking to see that $d_\theta$ is less
than or greater than $\pi$. Finally, we take the vector components of
the desired heading $tx=cos(heading_{dest})$, $ty=-sin(heading_{dest})$
and dot these with the vectors from the start point to the current point
$xrs*nx+yrs*ny$. We take this product and add it to $d_\theta$ to get
the final corrected heading $-K_d*offset+K_{\theta}*d_\theta$.

\subsection{Implementation}

The \texttt{steering\_example.cpp} sample code was tweaked to include a
file reader to allow us to easily modify constants $K_d$ and $K_\theta$.
We also ended up coding a rudimentary path planner that has hard coded
path segments.

\subsection{Observations}

We ran into several problems when trying to perfect our steering code.
The hardest part of this demo was getting all of the previous nodes
integrated and functioning. We had to integrate several dummy messages
and structures to glue together everything until all the nodes can be
completed.

\subsection{Observations}

Our tests for the demo showed that the linear steering algorithm works
just fine for the relatively small imperfections in path encountered
during normal operation. However, for very large offests we did not
always get the desired results.

We found that the values of $K_d=0.5$ and $K_\theta = 1.0$ worked well
for the robot.

\subsection{Future Plans}

\begin{itemize}
\item
  Non-linear steering: We plan on replacing the linear steering
  algorithm with the non-linear one
\item
  Arc path steering: We plan on generating arch path segments and
  allowing the steering node to maintain control over these segments.
\item
  Python source code: We plan on porting all of our existing code to
  python. We would like to utilize rospy for ease of programming and to
  get rid of compile time.
\end{itemize}
