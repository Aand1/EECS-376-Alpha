\section{Steering Node}

The Steering node is responsible for taking the desired velocities from
the velocity planner, the desired path from the path planner, and the
current position to determine correction factors to the velocity command
such that the robot does not stray from its desired path.

\subsection{Theory of Operation}

The velocity profiler's job is to decide what velocity the robot
should be moving at for each point along the path.  The steering
node's job is to take the desired velocities and add correction
factors to them.

To do so steering subscribes to the des\_vel topic published by
Velocity Profiler.  In turn Velocity Profiler subscribes to the
velocity command actually sent to the robot. Velocity Profiler uses
this information to correct its internal state so that it is inline
with the robot's actual state.  The process runs continously forming a
cycle.

\subsubsection{Steering Algorithm}

\paragraph{Steering to a Path Segment}

We used the linear steering algorithm. This algorithm takes a number
of inputs such as:

\begin{itemize}
\item
  The $x$ and $y$ coordinates of the destination.
\item
  The current $x$ and $y$ coordinates.
\item
  Tuning parameters $K_d$ and $K_\theta$
\end{itemize}
First we use the path segment coordinates to calculate the desired
heading with the following: $atan(yf-ys,xf-xs)$. Next we find a
$d_\theta$ by subtracting $heading_{dest}-heading_{curr}$. We can
prevent turning the long way by checking to see that $d_\theta$ is less
than or greater than $\pi$. Finally, we take the vector components of
the desired heading $tx=cos(heading_{dest})$, $ty=-sin(heading_{dest})$
and dot these with the vectors from the start point to the current point
$xrs*nx+yrs*ny$. We take this product and add it to $d_\theta$ to get
the final corrected heading $-K_d*offset+K_{\theta}*d_\theta$.

\paragraph{Steering to a Point}

For the strap following demo we used a bread crumb approach to path generation. Essentially instead of coming up with an entire path based on the sensor data we use only the closest desired point. Because this does not use a segment like in the other algorithm we had to modify the algorithm a bit.

When steering to a point steering simply computes a line from the robot's current position to the specified point. It currently uses a constant velocity, but this could easily be changed to accelerate and decelerate and do more complicated things.

It differs from steering to a path segment in that it assumes it has no offset from the desired path only an offset in orientation. In other words it controls only spin not forward velocity.

\subsection{Observations}

Our tests for the demo showed that the linear steering algorithm works
just fine for the relatively small imperfections in path encountered
during normal operation. However, for very large offests we did not
always get the desired results.

We found that the values of $K_d=0.5$ and $K_\theta = 1.0$ worked well
for the robot.

Before spring break we had planned on implementing a non-linear steering algorithm, however, the linear algorithm functioned just fine for our purposes throughout the entire semester. There was an attempt at making a non-linear steering algorithm, however, it was not debugged and so it crashes on start up because of indexing errors. This code can be found in a previous version in our repository.
