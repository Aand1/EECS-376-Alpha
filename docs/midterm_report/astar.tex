\section{Astar Node}

The Astar node is responsible for generating the most optimal path given a list of closed points from a rolling costmap and a goal from the goal publisher.

\subsection{Theory of Operation}
After a costmap is generated it publishes to the topic inflated\_obstacles. The Astar node listens to that topic and converts each obstacle's map position into the node's own grid frame. AStar also listens to the goal\_point topic to find out the desired destination in map coordinates. The goal point is also converted to the node's grid frame. The node takes the obstacle points and adds them to a closed list. From the closed list the Astar node is able to generate the most optimal path to the goal point.


\subsubsection{AStar Algorithm}
The robot's starting position is added to the open list. The neighboring location on the map with the lowest F is added to the open list and then switched to the closed list. For each adjacent location:

\begin{itemize} 
\item If the space is an obstacle or on the closed list ignore it.
\item If it is not on the open list add it to the open list. Make the current square the parent of the square and update the cost, heuristic, and sum of the cost and heuristic.
\item If a list is on the open list already check to see if the path through this location is better than the current location.
\end{itemize}

The search stops when one of the goal locations is the next item on the open list or the open list is empty. When the open list is empty no path exists.

The algorithm then generates the path by tracing back the pointers to the parents.

 This algorithm takes a number
of inputs such as:
\begin{itemize}
\item
  A list of closed points in map coordinates
\item
  A goal location in map coordinates
\item
  The current position of the robot in map coordinates
\end{itemize}


\subsection{Implementation}
To make the algorithm run faster and yet still be flexible we specify two parameters in the launch file called c1 and c2. These represent two corners. There is also a parameter called numCells. These corners define a grid that spans the area of a rectangle with the corners specifying the corners of the rectangle. The number of cells in the grid is numCells by numCells. This meant we could specify an A* search over a specific area in the map instead of examining the entire map. This allows the search space to be cut down significantly and allows for a finer grained search in the area of interest.

\subsection{Observations}
We noticed that when the A* algorithm was responding to obstacle stimulus from the sensors it would try to get as close to the obstacle as possible. This was because all of the states in our grid had the same cost of 1. If we were to actually use this we would have given a step cost of the inverse of the distance to the closest obstacle. We would also have to modify our heuristic to make sure it remained admissible. We would use the bounds on our hallway to scale the Euclidean distance heuristic so that it was guaranteed to be at least as small as any path that could actually be found.

\subsection{Lessons Learned}
While our software architecture helped us to properly distribute labor and the encapsulation of data between nodes,
we neglected to make use of a contingency plan. Our production chain was broken at the costmap and our A* node depended
on the working costmap. If we could redo the final we would have had a backup plan to generate closed list points
through our own code. For instance we could have used LIDAR data to generate wall points to go into the closed list of the A* search node.
