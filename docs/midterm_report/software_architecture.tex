\part{Software Architecture}

Before writing the code for the demos, we started by coming up with an
overall software architecture.  The purpose of this planning was to
write each node so that as other nodes are added to our software
package we do not have to spend time rewriting old code.

This section will describe the decisions we made and what we have
planned.

\section{Node Architecture}

The main document we are basing our software architecture off of is
the following:

\FloatBarrier
\missingfigure{Attach the updated software architecture drawing}
\FloatBarrier


This figure clearly shows the different nodes we have planned, the
communication message types being passed between them, and areas of
possible future expansion.

The specifications for the nodes in the diagram and the messages being
used will be found in the rest of this section.

\input{stacks_packages}

\section{Node Specifications}

To help guide us while writing our nodes we wrote a small
specification for each class seen in the software architecture diagram.

\subsection{Velocity Profiler}
\todo[color=red,inline]{This needs to be updated with a more accurate discription}
This nodes is responsible for taking in a list of path segments through the PathList and PathSegment message. After receiving the specified path, velocity profiler calculates the optimum trajectory based on the velocity and acceleration constraints in specified in the path segments. In the process of computing the optimum trajectory velocity profiler will blend multiple segments into a single seamless trajectory. After the trajectory is computed velocity profiler is responsible for sending the desired velocity at each point to steering.

\subsubsection{Requirements}
\begin{enumerate}
  \item Velocity Profiler must accept PathList messages
  \item Velocity Profiler must calculate spatial trajectories from
        the accepted PathSegment messages
        \begin{enumerate}
           \item Velocity Profiler must obey all of the path constraints
                 specified in every accepted PathSegment message
        \end {enumerate}
  \item Velocity Profiler must respond to Obstacle messages from Look
        Ahead
        \begin{enumerate}
           \item Velocity Profiler must stop and wait at an obstacle for a
                 specified amount of time
           \item Velocity Profiler must alert Path Planner if an obstacle
                 has not moved after a specified time
        \end{enumerate}
   \item Velocity Profiler must publish a desired velocity based on the computed trajectory
   \item Velocity Profiler must stop when the E-Stop is enabled
   \item Velocity Profiler must resume a plan after the E-Stop is
         disabled
\end{enumerate}
      
\subsection{Look Ahead}

This node enables reactive obstacle detection. As the name implies it is responsible for ``looking'' ahead for obstacles along the path. Currently it uses the LIDAR but using either the costmap or custom code this could be expanded for other sensors such as the Kinect.

  \subsubsection{Requirements}
  \begin{enumerate}
     \item Look Ahead will parse the data from the LIDAR
     \item Look Ahead will detect objects within a minimum of 1 m along the specified path
     \item Look Ahead will exclude obstacle detection of all objects
           outside of the planned path
  \end{enumerate}

\subsection{Steering}
  \todo[color=red,inline]{Should add a little better description}
  This node is responsible for correcting the small differences
  between desired and actual heading. It takes in a desired velocity and scales
  its own steering around that value based on the segment type.

  \subsubsection{Requirements}
  \begin{enumerate}
     \item Steering will accept a list of paths
     \item Steering will correct the desired velocities from Velocity
           Profiler
     \item Steering will obey stopping commands in the desired velocity
     \item Steering will stop correcting the path when the E-Stop is pressed.
  \end{enumerate}

\subsection{Path Planner}

This node is responsible for taking in a set of path points and converting it to a list of path segments that form a path through the desired points. It is allowed to throw out conflicting data and select path segment parameters such as the speed.

  \subsubsection{Requirements}
  \begin{enumerate}
    \item Path Planner will receive a list of path points
    \item Path Planner will send out the calculated path in segments
    \item Path Planner will respond to requests for new paths
    \item Path Planner will correct its computed path based on new information in the path point list
  \end{enumerate}

\todo[color=green,inline]{Fill in new node specifications}
\subsection{Path Finder}

     \subsubsection{Requirments}
     \begin{enumerate}
       \item stuff
     \end{enumerate}
 
\subsection{Kinect}

  \subsubsection{Requirments}
  \begin{enumerate}
    \item stuff
  \end{enumerate}

\subsection{Costmap}

  \subsubsection{Requirments}
  \begin{enumerate}
    \item stuff
  \end{enumerate}
       

\subsection{A Star Search}

   \subsubsection{Requirments}
   \begin{enumerate}
     \item stuff
   \end{enumerate}

\todo[color=red,inline]{Check the definitions of new message specifications.}

\section{Custom Message Specifications}

\subsection{SegStatus}

Responsible for holding information about the status of a path
segment.  The message format is as follows:

\noindent {\bf bool segComplete}\\
\indent True if segment has been completed\\
\indent False if segment is still being executed\\
\\
{\bf uint64 seg\_number}\\
\indent Stores the number identifying the segment the message is
pertaining to.\\
\\
{\bf float64 distance}\\
\indent Stores the distance remaining on a segment.\\


Responsible for holding information about obstacles in the path
segments.  The message format is as follows:

\noindent {\bf bool exists}\\
\indent True when 1 or more obstacles detected in path\\
\indent False when 0 obstacles are detected in path\\
\\
{\bf float64 distance}\\
\indent The distance to the closest obstacle

\subsection{BlobDistance}
The Kinect Listener publishes the distance from the center of an image
to the center of a blob.

\noindent {\bf uint32 dist}\\
\indent Distance from the center of the blob to the center of the vision\\

\subsection{CentroidPoints}
Contains the list of coordinates of the centroids of the slices along the orange strap.
\noindent {\bf bool exists}\\
\indent \todo[color=red,inline]{What is the purpose of exists in centroid points}
\noindent {\bf geometry\_msgs/Point point}
\indent The point at which the centroid is.

\subsection{Goal}
Incrementally updates goals for the A $\ast$ search node.

\noindent{\bf bool new}\\
\indent True when a new goal is published.

\noindent{\bf bool none}\\
\indent Set to true when the robot should not change its present location.

\noindent{\bf geometry\_msgs/Point goal}\\
\indent The coordinates of the desired goal

\subsection{PathList}
A list of coordinates the A $\ast$ search publishes from the robots current position to the goal.

\noindent {\bf msg\_alpha/PathSegment[] segments}\\
\indent The coordinates of each point the robot must go to in order to reach the goal.

\subsection{PathSegment}
Path Segments that are generated by the Path Planner node.

\noindent {\bf int8 seg\_type}\\
\indent The segment type can be a line, arc, or spin, 1,2 or 3 respectivley.

\noindent {\bf bool relative}\\
\indent Set to true when the path is in the robot's coordinate frame.\\
\indent Set to false when the path is in the map's coordinate frame.

\noindent{\bf float64 seg\_length}\\
\indent The length of a path segment.

\noindent{\bf geometry\_msgs/Point ref\_point}\\
\indent The reference point of a path segment.

\noindent{\bf geometry\_msgs/Quaternion init\_tan\_angle}\\
\indent The initial tangent angle of a path segment.

\noindent{\bf float64 curvature}\\
\indent The curvature of a path segment.

\noindent{\bf geometry\_msgs/Twist max\_speeds}\\
\indent Maximum speed for a path segment.

\noindent{\bf geometry\_msgs/Twist min\_speeds}\\
\indent Minimum speed for a path segment.

\noindent{\bf float64 accel\_limit}\\
\indent Acceleration limit for a path segment 

\noindent{\bf float64 decel\_limit}\\
\indent Deceleration limit for this segment.

\subsection{PointList}
\noindent{\bf bool new}\\
\indent{\bf geometry\_msgs/Point[] points}






\section{Topics}

\subsection{des\_vel}
Velocity Profiler publishes the desired velocity based on the robot's
current point in space the current and next path segments.  This
velocity is then corrected by steering.

\subsection{cmd\_vel}
Steering publishes the final velocity to the robot's motors.  The
final velocity is a corrected version of the velocity in the des\_vel topic.

\subsection{base\_laser1\_scan and base\_scan}
base\_laser1\_scan is used on the robot\\
base\_scan is used in the simulator\\

\noindent Used to send out LIDAR data from the cRIO.

\subsection{seg\_status}
Velocity profiler publishes the status of its current segment on this
topic.  Nodes such as steering subscribe to it.

\todo[inline]{Check over descriptions}

\subsection{path\_seg}
Path Publisher publishes the planned path segments to this topic.  The
published segments are used by steering, velocity\_profiler and other nodes.

\subsection{point\_list}
AStar publishes a list of points for the pathplanner to generate path segments from.
\subsection{goal\_point}
The goal publisher sends a goal to the AStar node that determines the end point of the A star search.
\subsection{path}
The path list determiend by the path planner.
\subsection{obstacles}
Look ahead publishes whether or not there is an obstacle within the bounded box area directly in front of the robot.
\subsection{motors\_enabled}
Estop publishes whether or not the estop is off.
